---
title: 性能优化-LCP
date: 2024-8-15 13:17:08
tags: [性能优化, LCP]
---

## 性能优化-LCP（Largest Contentful Paint）

### 问题和客观事实

先看一张网页加载的完整 LCP 示例

![](/images/lcp1.png)

**整个 LCP 的加载分为四部分：**

1. `TTFB`：用户从启动网页到收到 HTML 文档响应的第一个字节（代表浏览器能够开始发现渲染此网页所需要资源的第一时刻）
2. `LCP资源加载延迟`：TTFB 到网页加载 LCP 所需资源的时间差（某些情况下，LCP 资源可以在不加载任何额外资源的情况下渲染，比如 LCP 元素是使用系统字体的文本节点）
3. `资源加载时长`：LCP 资源本身加载所需的时间（如果不发出请求，那通常所需时间也为 0）
4. `元素渲染延迟`：从 LCP 资源加载完成到实际渲染到页面上所经过的时间

**仅优化资源加载时间**

![](/images/lcp2.png)

如上图所示，如果我们仅优化资源加载的时间，那么 LCP 不会有任何变化。因此，我们应该处理上述四部分中每一部分的加载时间，到建议的阈值

**合理阈值**

![](/images/lcp3.png)

**某网站所有用户访问所需 LCP 的统计**

![](/images/lcp4.png)

**各区间的占比**

![](/images/lcp5.png)

通常我们会认为资源加载会占据大部分（也就是绿色条），实际上并不是，而是资源加载延迟（紫色条）

### 如何优化

**优化步骤：**

1. 消除不必要的资源加载延迟。做资源预加载（图片静态资源）

![](/images/lcp6.png)

2. 消除不必要的元素渲染延迟。优化 js 文件体积，也就是减少阻塞时间

![](/images/lcp7.png)

SSR 渲染、预渲染为静态文件，这样 js 代码完全不会阻塞渲染

![](/images/lcp8.png)

3. 尽可能减少资源加载时间。优化图片、使用缓存、CDN

![](/images/lcp9.png)

去除未使用的 css 代码，减小 css 文件体积（为了避免牺牲质量采取折中方案）

![](/images/lcp10.png)

4. 减少首字节时间。后端在做出首字节响应之前，浏览器不会做任何事。

![](/images/lcp11.png)

**实际案例**

1. 消除不必要的资源加载延迟，优化图片资源预加载。如下代码可以是浏览器通过 HTML 源码发现图片资源，而不必等待 js 和 API 请求完成，即可加载图片

![](/images/lcp12.png)

![](/images/lcp13.png)

优化结果如下。可以看到图片提前加载了，但并未与 css 资源同时加载，这是因为相关 js 代码并未运行，图片不在视口中，所以浏览器默认分配了低优先级

![](/images/lcp14.png)

使用 fetchpriority API 设置更高的优先级

![](/images/lcp15.png)

优化结果如下。图片加载时间与 css 加载时间相同，并且资源加载延迟极大的缩短

![](/images/lcp16.png)

2. 消除不必要的元素渲染延迟，使用 SSR 渲染。结果如下

![](/images/lcp17.png)

进一步优化，优化图片格式为最佳格式 avif 或 webp。使用 picture 标签，可以自动选择最佳的图片格式

![](/images/lcp18.png)

结果如下。资源加载延迟不降反升，

![](/images/lcp19.png)

原因在于，我们没有更新 link 标签预加载的图片类型，并且 avif 和 jpeg 两种格式都加载了。那我们能否有条件预加载图片资源？

![](/images/lcp20.png)

我们可以废弃 link 方式，改用在 img 中使用 fetchpriority API 的方式处理，浏览器会自动选用最合适的图片版本

![](/images/lcp21.png)

结果如下，图片资源被优先加载

![](/images/lcp22.png)

内容来源：[https://web.dev/articles/optimize-lcp?hl=zh-cn](https://web.dev/articles/optimize-lcp?hl=zh-cn)
