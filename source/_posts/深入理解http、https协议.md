---
title: 深入理解http协议
date: 2024-03-24 17:27:09
tags: [HTTP, TCP]
---

## 前言

相信很多前端的小伙伴在面试的时候经常会被问到 http 相关的问题，但是工作中我们又好像并没有用到过，或者并没有关注了解过，导致在回答的过程中经常语塞。那么，今天我就以前端的视角结合面试和工作中经常会遇到的问题跟大家分享一下我的理解。

### 阅读本篇内容你将收获到以下知识：

1. OSI 模型以及各模型的介绍
2. TCP 协议的三次握手，四次挥手
3. 页面从输入 `url` 到渲染出来经历了哪些过程
4. http 各个版本的区别

## 正文

### OSI 模型以及各模型的介绍

首先，我们需要知道当我们从客户端发出一个请求到服务端，都有哪些模块参与了工作，各自又负责什么工作。

我们来看一张图：

![](/images/http-01.png)

这就是我们常说的 `OSI` 七层模型或者五层模型，他们的区别不过对于 `应用层` 的划分，七层模型做了更细致的划分，这里的区别了解这一点就行了。然后我们看一下 `应用层` 用到的协议，我们比较熟悉的有 `DNS`、`HTTP` 协议，这一层主要做的事情是：

1. 将我们发起请求的域名通过缓存或者 `DNS` 解析的方式得到服务器的 `ip` 地址。
2. 对数据进行包装，带着 `HTTP` （该层协议的）的请求头和请求体进入到 `传输层`。

`传输层` 中我们比较熟悉的协议有 `TCP`、`UDP`。这一层主要做的事情是：

1. 解析 `应用层` 信息中的 `HTTP` 请求头，拿到请求体
2. 对数据进行包装，带着 `TCP` 或者 `UDP` （该层协议的）的协议头和请求体进入到 `网络层`。

`网络层`、`数据链路层`、`物理层` 我们都比较熟悉，他们所做的事情也跟 `传输层` 一样，都是先对上一层的数据进行解析，拿到请求体，然后再对请求体包装，然后向下一层传输。

OK，我们现在已经对 `OSI` 模型有一个全面的认识了。那我们我们继续来思考一个问题：**这个模型为什么要拆分成五层或七层呢？**

我们首先要知道 `OSI` 模型是什么，它 `是为了提供一个不同计算机和网络系统之间通信的标准化框架`。也就是说 `OSI` 模型本身就是一个程序，那结合到我们的日常开发中，我们所开发的项目也是程序，我们在项目开发的过程中是不是也要对程序做各种拆分？常见的：数据层、控制层、渲染层等等。那其实对于 `OSI` 模型来说也是一样的，它本身也是一个非常复杂的程序，他也要做同样的拆分工作。

### `TCP` 协议的三次握手，四次挥手

这是一个老生常谈的问题，我们先给出结论，再深挖一下细节：

**三次握手**

![](/images/http-2.png)

`TCP/IP` 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接，

1. 那么第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN 标志位置为 1，表示发起新的连接。
2. 当服务端收到这个报文之后就知道客户端要和我建立一个新的连接，于是服务端就向客户端发送一个确认消息包，在这个消息包里面：ack 标志位置为 1，表示确认客户端发起的第一次连接请求。以上两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。
3. 所以，还需要进行第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个 ack 标志位置 1 的确认消息。通过以上三次连接，不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。那么，这个连接就被安全的建立了。

我们平时关注到的都是浏览器 `network` 中的 `http` 请求，很少会关注到 `TCP` 请求，我们今天来看一下 TCP 请求的报文到底长什么样子：

![](/images/http-3.png)

我们可以清晰的看到这三次握手的过程，以及每次握手时携带的报文信息。尤其要说明一点，也是我以前没太在意的，就是这三次请求的 `SYN码` 和 `ACK码` 真的是 **+1** 的关系。

**四次挥手**

1. 四次握手机制也是由客户端去发起，客户端会发送一个报文，在报文里面 FIN 位标志位置一，当服务端收到这个报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的这个消息的时候，对于服务端而言，他和还有可能有未发送完的消息，他还要继续发送
2. 所以呢，此时对于服务端而言，我只能进行一个消息确认，就是我先告诉服务端，我知道你要给我断开连接了，但是我这里边还可能没有做好准备，你需要等我一下，等会儿我会告诉你
3. 于是呢，发完这个消息确认包之后，可能稍过片刻它就会继续发送一个断开连接的一个报文啊，也是一个 FIN 位置 1 的报文也是由服务端发给客户端的啊，这个报文表示服务端已经做好了断开连接的准备
4. 那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文一共有四次，那么，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的

![](/images/http-4.png)

细心的朋友可能会注意到，第四次挥手之后，客户端为什么还要等待 2MSL 的时间才会关闭连接，而不是立马关闭呢？

1. **确保服务器收到最后的 ACK**：当客户端发送了终止连接的 FIN 报文后，服务器会发送一个 ACK 应答。客户端需要等待足够长的时间（即 2MSL），以确保这个 ACK 报文能够到达服务器，因为网络延迟或者路由问题可能会导致报文延迟。
2. **允许服务器发送最后的数据**：在客户端发送了终止连接的 FIN 之后，服务器可能会有一些数据已经发送到网络中，但还没有到达客户端。如果客户端立即关闭连接，可能会导致服务器发送的数据丢失。
3. **防止旧的重复数据包**：在等待 2MSL 的时间内，任何在该时间内旧的数据包都会因为超时而被删除，这样可以防止在旧的连接没有被完全关闭的情况下，旧的或者损坏的数据包对新的连接产生影响。
4. **让网络层清理资源**：等待一段时间还可以让网络层有足够的时间来清理与这个连接相关的任何资源，比如网络 buffers 中的数据等。

综上所述，等待 2MSL 的时间是确保 TCP 连接被正确、完全地关闭，以及让网络环境清理与该连接相关的所有资源。这样，就可以避免潜在的数据丢失或混淆，并确保网络的稳定性和可靠性。

### 页面从输入 `url` 到渲染出来经历了哪些过程

了解完上述基本的概念后，我们来看一个经典的面试题，相信大家也都遇到过：页面从输入 `url` 到渲染出来经历了哪些过程？

我们结合两张图来完整的描述一下整个过程：

![](/images/http-6.png)

![](/images/http-7.png)

1. 输入地址并确认后，浏览器对域名进行访问，浏览器对域名进行解析，如果浏览器有域名对应的 DNS 相关信息的缓存，有的话可以拿到服务端的 IP 地址，如果没有的话，会去本地的 host 文件查看是否进行了配置，如果 host 文件没有配置相关的信息，那么就会发起 DNS 的请求用来获取对应的服务器的 IP 地址。
2. 应用端会构造 DNS 的请求报文，应用层会调用传输层的 TCP 的相关协议进行数据传输，会在 DNS 的基础上加上 TCP 的请求头然后传输信息至网络层，
3. 网络层会在 TCP 的请求报文基础上加上 IP 的请求头然后到数据链路层，
4. 数据链路层会实现二层寻址，会加上自己的 mac 信息和通过网络层的 ARP 协议里拿到的下一步基地的 mac 信息一起通过物理层一起传输出去，通常传到路由器，
5. 然后路由器这个三层设备最终会通过运营商的路线传输到下一个路由器地址，达到服务器后
6. 信息通过相同步骤进行层层解析 HTTP 的请求报文，然后构造 HTTP 响应报文沿着相同的步骤传输至客户端。
7. 把请求回来的 HTML 代码经过解析，构建成 DOM 树；
8. 计算 DOM 树上的 CSS 属性；
9. 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；
10. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；
11. 合成之后，再绘制到界面上。

这里我们追加一个问题放到下一篇文章解答：**收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？** 大家可以期待一下 😁

### http 各个版本的区别

直接上图：

![](/images/http-8.png)

http2 的问题

1. tcp 协议传输的字节流是有序的，会造成队头的阻塞。这使得多路复用的能力大打折扣
2. TCP 和 TLS 叠加了握手延时
3. 网线时代用 TCP 四元组确定一个链接的方式并不适用于无线时代，ip 的频繁变动会导致 TCP 连接、TLS 会话的反复握手，成本高昂

http3 的优化

1. 基于 UDP 协议重新定义了连接，使用无序、并发的字节流传输，解决了队头阻塞的问题
2. http3 重新定义了 TLS 协议加密 QUIC 头的方式，既提高了安全性，又降低了建连速度。只需要 1 个 RTT（补充：RTT(Round-Trip Time):往返时延 建立连接要 1 个 RTT 申请对象及接收要 1 个，因此 http2 时代 TCP 连接要 1 个 RTT、TLS 会话要一个 RTT）
3. HTTP3 将 Packet、QUIC Frame、HTTP3 Frame 分离，实现了连接迁移功能，降低了 5G 环境下高速移动设备的连接维护成本

## 后序

感谢观看～
