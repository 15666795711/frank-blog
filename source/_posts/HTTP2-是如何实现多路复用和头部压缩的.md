---
title: HTTP2 是如何实现多路复用和头部压缩的
date: 2024-04-24 15:30:07
tags: [HTTP, HTTP1.1, HTTP2]
---

1. 二进制分帧 - HTTP2 数据中几个重要的概念-帧、消息、流
2. 头部字段压缩
3. 多路复用

## 前言

我们在[一个 TCP 请求可以发多少个 HTTP 请求](/frank-blog/2024/03/24/深入理解http、https协议/)中讨论了 HTTP1.1 存在的一些问题以及在 HTTP2 中的解决方案，我们本篇文章就来深入探讨一下 HTTP2 中这些解决方案是怎么实现的。

## 正文

### 二进制分帧

#### HTTP2 数据中几个重要的概念-帧、消息、流

- **帧 frame**：HTTP2 中最小通信数据单元，每个帧至少包含了一个标识（stream identifier，简称 stream id）该帧所属的流。

- **消息 message**：消息由一个或多个帧组成。例如请求的消息和响应的消息。

- **流 stream**：存在于 HTTP2 连接中的一个“虚拟连接通道“，它是一个逻辑概念。流可以承载双向字节流，及是客户端和服务端可以进行双向通信的字节序列。每个流都有一个唯一的整数 ID（stream identifier） 标识，由发起流的一端分配给流。

  单个 HTTP2 连接可以包含多个同时打开的流，任何一个端点（客户端和服务端）都可以将多个流的消息进行传输。这也是多路复用关键所在。一个 TCP 连接（HTTP2 连接建立在 TCP 连接之上）里可以发送若干个流（stream），每个流中可以传输若干条消息（message），每条消息由若干二进制帧（frame）组成。

  任何一端都可以关闭流。在流上发送消息的顺序很重要，最后接收端会把 Stream Identifier (同一个流) 相同的帧重新组装成完整的消息报文。特别是 HEADERS 帧和 DATA 帧的顺序在语义上非常重要。

  HTTP2 中连接 Connection、流 Stream、消息 Message、帧 Frame 的关系示意图如下：

  ![](\images\http2-1.png)

#### 二进制分帧层(HTTP2 格式框架)

![](\images\http2-2.png)

从上图可以看出 HTTP1.1 是 `明文文本` ，而 HTTP2.0 首部（HEADERS）和数据消息主体（DATA）都是 `帧（frame）`。frame 是 HTTP2 协议中最小数据传输单元。

#### 帧 Frame 的格式

一旦建立了 HTTP2 连接，端点（endpoints）间就可以开始交换帧数据。

所有的帧数据都是以一个固定的 9 字节开头(Frame Payload 之前)，后面跟一个可变长度的有效负载 Frame Payload，这个可变长度的长度值由字段 Length 来表示。

帧的格式：

```
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
```

- **Length**：24 个 bit 的无符号整数，用来表示 Frame Payload 的长度占用字节数。这个 Length 值的范围为 0 - 16384(2^14)。触发接收方设置了一个更大的值 SETTINGS_MAX_FRAME_SIZE 。帧头的 9 字节不包含在这个 Length 值中。

- **Type**：定义 Frame 的类型，8 bits 表示。帧类型决定了帧的格式和语义。实现的话必须忽略或抛弃未知类型的帧。

- **Flags**：为帧 Frame 类型保留的 8 bit 的布尔值，这个标志用于特定的帧 Frame 类型语义。如果这个字段没有被标识为特定帧类型语义，那么接收时必须被忽略，并且发送时不设置（0x0）。

- **R(Reserved)**：一个保留的 1 bit 字段，这个字段语义未定义。发送时必须保持未设置（0x0），接收时忽略。

- **Stream Identifier**：流标识，31 bit 的无符号整数。值 0x0 保留给与整个连接相关联的帧，而不是单个流。

- **Frame Payload**：内容主体，由帧的类型决定。

#### 有哪些帧类型 Type

上一小节的 Type 字段，即帧类型，在 HTTP2 中共分为 10 种类型：

每一种类型帧都由一个 8 位类型代码来识别。每种帧类型在建立和管理整个连接或单个数据流时都有不同的作用，

![](\images\http2-3.png)

（from：https://httpwg.org/specs/rfc9113.html#FrameTypes）

### 多路复用

在 HTTP1.1 中，一个 HTTP 的数据传输需要建立一个 TCP 连接，虽然有 Pipleing 特性，但是也有队头阻塞的问题。

**在 HTTP2 中，在一个 TCP 连接中，可以发起多个 HTTP2 连接请求，而每个 HTTP2 连接中又可以发起多个流来传输数据。这都得益于 HTTP2 中数据格式的设计，最重要的流概念。**

来看一看网络上的一张图

![](\images\http2-4.png)

从图中可以看到在 HTTP1.1 中，请求 index.html 资源，响应完毕后就关闭连接了。

而**在 HTTP2 中，请求完资源后，连接仍然是打开的，后面还可以继续使用这个连接通道传输数据。**

上面是从资源传输的角度对比了 2 者的特性。

下面从 HTTP2 中 stream（流）角度来看看多路复用：

![](\images\http2-5.png)

上图可以看到在一个 HTTP2 connection 中，客户端和服务端双方都能够向对方发送多个流数据（stream 1、stream 3、stram 5），在 HTTP2 中用这个 stream ID 来标识帧和流的对应关系。

也就是说，客户端和服务端建立 TCP 连接后，就可以通过流的方式来进行数据传输，然后接收端再对收到的数据按照 Stream Identifier 进行组装，而且一个 TCP 连接可以发送若干个流，这样就解决了队头阻塞的问题，并且数据也可以并行发送，大大提高了网络性能。

### 头部压缩

HTTP 1.1 请求头的协议内容很多，而且大部分都是重复的。在 HTTP1.1 中每次请求都会大量携带这种冗余的头信息，浪费流量。

在 HTTP2 中，设计了 HPACK 压缩算法对头部协议内容进行压缩传输，这样不仅数据传输速度加快，也能节省网络流量。

HPACK 原理:

- 客户端和服务端共同维护了一份静态字典表（Static Table），其中包含了常见头部名及常见头部名称与值的组合的代码。
- 客户端和服务端根据先入先出的原则，共同维护了一份能动态添加内容的动态字典表（Dynamic Table）。
- 客户端和服务端支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）。

![](\images\http2-6.png)

也就是说，客户端在发送 HTTP 请求的时候会对 HTTP Header 数据 先在动态字典和静态字典中检索，如果已存在，那么会将对应的数据转换成哈夫曼编码，如果没有，那么会在动态字典中生成一个新的编码，全部转换完成后也就将原来的一串文本数据转换成了一串哈夫曼编码，然后将这一串哈夫曼编码传输给服务端（注意这里还包含动态字典里新生成的编码），后端会将新增的编码添加到动态字典中，然后解码成文本（即在静态字典和动态字典中查找编码对应的数据）。

上述过程中，原本传输的文本被替换为了哈夫曼编码，以此来实现了头部数据的压缩。

## 后序

本篇文章分享结束，希望对大家有帮助，感谢观看~
